name: Final-Project CI/CD Pipeline

on:
  push:
    branches: [ main, develop]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    

env:
  PYTHON_VERSION: '3.10'
  STAGING_USER_PORT: 4001
  STAGING_PRODUCT_PORT: 4002
  STAGING_USER_MYSQL_PORT: 4308
  STAGING_PRODUCT_MYSQL_PORT: 4309
  STAGING_MYSQL_PORT: 3306
  STAGING_USER_MYSQL_DB: 'user_staging'
  STAGING_PRODUCT_MYSQL_DB: 'product_staging'
  STAGING_USER_MYSQL_USER: 'staging_user'
  STAGING_PRODUCT_MYSQL_USER: 'staging_product_user'

jobs:
  
  test-all-services:
    runs-on: ${{ matrix.os }}
    env:
      USER_SERVICE_PORT: 3001
      PRODUCT_SERVICE_PORT: 3002
    strategy:
      matrix:
        os: [ubuntu-latest]
        mysql_version: ['8.0']

    services:
      mysql-user:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
      mysql-product:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3307:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Creating test environment file
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          cat > .env.test << EOF
          SECRET_KEY=test_fallback_secret_key_123
          USER_MYSQL_HOST=localhost
          USER_MYSQL_USER=test_user
          USER_MYSQL_PASSWORD=test_password_123
          USER_MYSQL_DB=auth_test
          USER_MYSQL_PORT=3306
          PRODUCT_MYSQL_HOST=localhost
          PRODUCT_MYSQL_USER=product_test_user
          PRODUCT_MYSQL_PASSWORD=test_password_123
          PRODUCT_MYSQL_DB=products_test
          PRODUCT_MYSQL_PORT=3307
          USER_SERVICE_URL=http://localhost:${{ env.USER_SERVICE_PORT }}
          PRODUCT_SERVICE_URL=http://localhost:${{ env.PRODUCT_SERVICE_PORT }}
          FLASK_ENV=test
          TESTING=True
          EOF

      - name: Install MySQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y mysql-client
      
      - name: wait for MySQL to be ready
        run: |
          until mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done

          until mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done
      
      - name: Initialize service database
        run: |
          mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 < user-service/init_test.sql
          mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 < product-service/product_init_test.sql

      - name: Install dependencies with coverage support
        run: |
          cd user-service && pip install -r requirements.txt 
          cd ../product-service && pip install -r requirements.txt 

      - name: Start user-service
        working-directory: ./user-service
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
        run: |
          echo "Starting user-service"
          python3 app.py &
          FLASK_PID_USER=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo $FLASK_PID_USER > user_service.pid 
          echo "User-service PID: $FLASK_PID_USER"
          sleep 30

      - name: Start product-service
        working-directory: ./product-service
        env:
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          echo "Starting product-service"
          python3 product_app.py &
          FLASK_PID_PRODUCT=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo FLASK_PID_PRODUCT > product-service.pid
          echo "Flask PID product-service: $FLASK_PID_PRODUCT"
          sleep 30
      
      -  name: Verification if both services are running
         run: |
          curl -f http://localhost:${{ env.USER_SERVICE_PORT }}/health && echo "User Service: OK"
          curl -f http://localhost:${{ env.PRODUCT_SERVICE_PORT }}/health && echo "Product Service: OK"

      - name: Run user-service tests with coverage 
        working-directory: ./user-service
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
        run: |
          python3 -m pytest tests/ -v --cov=app --cov-report=xml:user-coverage.xml --cov-report=html:user-htmlcov/ --cov-report=term -k "not functional"
          
      - name: Run product-service tests with coverage
        working-directory: ./product-service
        env:
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          python3 -m pytest products_tests/ -v --cov=product_app --cov-report=xml:product-coverage.xml --cov-report=html:product-htmlcov/ --cov-report=term -k "not functional"
      
      - name: Stop Flask services  
        if: always()
        run: |
          echo "Stopping Flask services"
          if [ -f user-service/user_service.pid ]; then
            kill $(cat user-service/user_service.pid) 2>/dev/null || true
          fi
          if [ -f product-service/product_service.pid ]; then
            kill $(cat product-service/product_service.pid) 2>/dev/null || true
          fi
          pkill -f "python3 app.py" || true
          pkill -f "python3 product_app.py" || true
          echo "Flask services stopped"

      - name: Upload tests artifacts and coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.run_id }}
          path: |
            user-service/tests/evidence/
            product-service/products_tests/products_evidence/
            user-service/user-coverage.xml
            product-service/product-coverage.xml
            user-service/user-htmlcov/
            product-service/product-htmlcov/
          retention-days: 14
      
      - name: Generate test summary
        if: always()
        run: |
          echo "#Test Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "##Test Statistics" >> $GITHUB_STEP_SUMMARY
          echo "-User Service Tests: 37" >> $GITHUB_STEP_SUMMARY
          echo "-Product Service Tests: 46" >> $GITHUB_STEP_SUMMARY
          echo "-Functional Tests: 8" >> $GITHUB_STEP_SUMMARY
          echo "-**Total Tests: 91**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Coverage Reports Generated" >> $GITHUB_STEP_SUMMARY
          echo "XML reports for CI integration" >> $GITHUB_STEP_SUMMARY
          echo "HTML reports for detailed analysis" >> $GITHUB_STEP_SUMMARY
          echo "Console output for immediate feedback" >> $GITHUB_STEP_SUMMARY
   
  deploy-staging:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    needs: test-all-services
    if: |
      github.ref == 'refs/heads/main' ||
      (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)

    environment:
      name: staging
      url: http://localhost:${{ env.STAGING_USER_PORT }} 

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install docker-compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker --version
          docker-compose --version

      - name: Set up docker buildx
        uses: docker/setup-buildx-action@v2

      - name: Cleanup previous staging runs
        run: |
          docker-compose -f docker-compose.staging.yml down -v 2>/dev/null || true

      - name: Check environment secrets availability
        run: |
          # Check STAGING_JWT_SECRET
          if [ -z "${{ secrets.STAGING_JWT_SECRET }}" ]; then 
            echo "STAGING_JWT_SECRET not available, using fallback"
            echo "STAGING_SECRET_KEY=staging_fallback_key_for_pr__$(date +%s)" >> $GITHUB_ENV
          else
            echo "STAGING_JWT_SECRET is available"
          fi
          
          # Check STAGING_USER_DB_PASSWORD
          if [ -z "${{ secrets.STAGING_USER_DB_PASSWORD }}" ]; then
            echo "STAGING_USER_DB_PASSWORD not available, using fallback"
            echo "STAGING_USER_MYSQL_PASSWORD=staging_user_pass_123" >> $GITHUB_ENV
          else
            echo "STAGING_USER_DB_PASSWORD is available"
          fi
          
           # Check STAGING_PRODUCT_DB_PASSWORD
          if [ -z "${{ secrets.STAGING_PRODUCT_DB_PASSWORD }}" ]; then
            echo "STAGING_PRODUCT_DB_PASSWORD not available, using fallback"
            echo "STAGING_PRODUCT_MYSQL_PASSWORD=staging_product_pass_123" >> $GITHUB_ENV
          else
            echo "STAGING_PRODUCT_DB_PASSWORD is available"
          fi

          echo "Secret check completed"

      - name: Deploy staging environment with docker-compose
        env:
          STAGING_SECRET_KEY: ${{ secrets.STAGING_JWT_SECRET || env.STAGING_SECRET_KEY }}
          STAGING_USER_MYSQL_PASSWORD: ${{ secrets.STAGING_USER_DB_PASSWORD || env.STAGING_USER_MYSQL_PASSWORD }}
          STAGING_PRODUCT_MYSQL_PASSWORD: ${{ secrets.STAGING_PRODUCT_DB_PASSWORD || env.STAGING_PRODUCT_MYSQL_PASSWORD }}
          STAGING_DB_ROOT_PASSWORD: ${{ secrets.STAGING_DB_ROOT_PASSWORD || env.STAGING_DB_ROOT_PASSWORD || 'staging_root_pass_123' }}
          STAGING_USER_PORT: ${{ env.STAGING_USER_PORT }}
          STAGING_PRODUCT_PORT: ${{ env.STAGING_PRODUCT_PORT }}
          STAGING_MYSQL_PORT: ${{ env.STAGING_MYSQL_PORT }}
          STAGING_USER_MYSQL_PORT: ${{ env.STAGING_USER_MYSQL_PORT }}
          STAGING_PRODUCT_MYSQL_PORT: ${{ env.STAGING_PRODUCT_MYSQL_PORT }}
          STAGING_USER_MYSQL_DB: ${{ env.STAGING_USER_MYSQL_DB }}
          STAGING_PRODUCT_MYSQL_DB: ${{ env.STAGING_PRODUCT_MYSQL_DB }}
          STAGING_USER_MYSQL_USER: ${{ env.STAGING_USER_MYSQL_USER }}
          STAGING_PRODUCT_MYSQL_USER: ${{ env.STAGING_PRODUCT_MYSQL_USER }}

        run: |
          docker-compose -f docker-compose.staging.yml up -d --build
          sleep 30

      - name: Verify staging deployment
        run: |
          max_retries=10
          for i in $(seq 1 $max_retries); do
            echo "Attempt $i/$max_retries"
            
            if curl -s -f http://localhost:${{ env.STAGING_USER_PORT }}/health > /dev/null && \
               curl -s -f http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health > /dev/null; then
              echo "Both services are healthy"
              
              # Verificação detalhada
              echo "Detailed health check:"
              curl -s http://localhost:${{ env.STAGING_USER_PORT }}/health | jq .
              curl -s http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health | jq .
              break
            fi
            
            if [ $i -eq $max_retries ]; then
              echo "Services not healthy after $max_retries attempts"
              exit 1
            fi
            
            sleep 10
          done

      - name: Verify test files exist in containers
        run: |
          echo "Checking if test files exist"
          docker-compose -f docker-compose.staging.yml exec user-service ls -la /user-service/tests/ || echo "User tests not found"
          docker-compose -f docker-compose.staging.yml exec product-service ls -la /product-service/products_tests/ || echo "Product tests not found"

      - name: Pre-Test Verification
        run: |
  
          echo "1. Service health:"
          curl -s http://localhost:${{ env.STAGING_USER_PORT }}/health | jq . || echo "User service health check"
          curl -s http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health | jq . || echo "Product service health check"
    
    
          echo ""
          echo "2. Testing database connection from user-service container:"
          # User Service DB Connection Test
          docker-compose -f docker-compose.staging.yml exec user-service python3 -c "
          import os
          import pymysql
          import sys

          print('Variables in container:')
          print(f'MYSQL_DATABASE: {os.getenv(\"MYSQL_DATABASE\")}')

          try:
            conn = pymysql.connect(
                host=os.getenv('MYSQL_HOST'),
                user=os.getenv('MYSQL_USER'),
                password=os.getenv('MYSQL_PASSWORD'),
                database=os.getenv('MYSQL_DATABASE'),
                port=int(os.getenv('MYSQL_PORT', 3306))
            )
            print(' Database connection SUCCESS!')
    
            with conn.cursor() as cursor:
                cursor.execute('SELECT DATABASE()')
                db = cursor.fetchone()
                print(f'Current database: {db[0]}')
        
                cursor.execute('SHOW TABLES')
                tables = cursor.fetchall()
                print(f'Tables in database: {[t[0] for t in tables]}')
    
            conn.close()
    
          except Exception as e:
              print(f'Database connection FAILED: {e}')
              sys.exit(1)
          "
        
          echo "3. product-service database connection test:"
          docker-compose -f docker-compose.staging.yml exec product-service python3 -c "
          import os
          import pymysql
          import sys
          print('Variables in container:')
          print(f'MYSQL_DATABASE: {os.getenv(\"MYSQL_DATABASE\")}')
          try:
            conn = pymysql.connect(
                host=os.getenv('MYSQL_HOST'),
                user=os.getenv('MYSQL_USER'),
                password=os.getenv('MYSQL_PASSWORD'),
                database=os.getenv('MYSQL_DATABASE'),
                port=int(os.getenv('MYSQL_PORT', 3306))
            )
            print(' Database connection SUCCESS!')
    
            with conn.cursor() as cursor:
                cursor.execute('SELECT DATABASE()')
                db = cursor.fetchone()
                print(f'Current database: {db[0]}')
        
                cursor.execute('SHOW TABLES')
                tables = cursor.fetchall()
                print(f'Tables in database: {[t[0] for t in tables]}')
    
            conn.close()
    
          except Exception as e:
              print(f' Database connection FAILED: {e}')
              sys.exit(1)
          "

          echo "4. Service communication test inside product-service container:"
          docker-compose -f docker-compose.staging.yml exec product-service python3 -c "
          import os
          import requests
          import sys
          user_service_url = os.getenv('USER_SERVICE_URL')
          print(f'User Service URL: {user_service_url}')
          try:
              response = requests.get(f'{user_service_url}/health', timeout=5)
              if response.status_code == 200:
                  print(' Communication SUCCESS!')
              else:
                  print(f' Communication FAILED: Status code {response.status_code}')
                  sys.exit(1)
          except Exception as e:
              print(f' Communication FAILED: {e}')
              sys.exit(1)
          "
      
      - name: Verify databases are separate
        run: |
    
          echo "Getting database names from containers..."
    
          USER_DB=$(docker-compose -f docker-compose.staging.yml exec -T user-service python3 -c "import os; print(os.getenv('MYSQL_DATABASE'))")
          PRODUCT_DB=$(docker-compose -f docker-compose.staging.yml exec -T product-service python3 -c "import os; print(os.getenv('MYSQL_DATABASE'))")
    
          echo "User Service Database: $USER_DB"
          echo "Product Service Database: $PRODUCT_DB"
    
          if [ "$USER_DB" = "$PRODUCT_DB" ]; then
            echo " ERROR: Both services using same database!"
            exit 1
          else
            echo " SUCCESS: Services using separate databases"
          fi

      - name: Run functional tests in staging environment 
        run: |
          echo "Running functional tests in staging environment"

          #User service functional tests
          docker-compose -f docker-compose.staging.yml exec -T user-service \
            timeout 300 python3 -m pytest /user-service/tests/test_functional.py -v --tb=short 2>&1 | tee /tmp/user-functional.log
          
          USER_EXIT_CODE=${PIPESTATUS[0]}
          if [ $USER_EXIT_CODE -eq 0 ]; then
            echo "User functional tests PASSED"
          elif [ $USER_EXIT_CODE -eq 124 ]; then
            echo "User functional tests TIMEOUT"
          else
            echo "User functional tests had issues (exit code: $USER_EXIT_CODE)"
          fi

          #Product service functional tests
          echo "Running product-service functional tests"
          docker-compose -f docker-compose.staging.yml exec -T product-service \
            timeout 300 python3 -m pytest /product-service/products_tests/test_product_functional.py -v --tb=short 2>&1 | tee /tmp/product-functional.log
          
          PRODUCT_EXIT_CODE=${PIPESTATUS[0]}
          if [ $PRODUCT_EXIT_CODE -eq 0 ]; then
            echo "Product functional tests PASSED"
          elif [ $PRODUCT_EXIT_CODE -eq 124 ]; then
            echo "Product functional tests TIMEOUT"
          else
            echo "Product functional tests had issues (exit code: $PRODUCT_EXIT_CODE)"
          fi
      
      - name: Record deployment
        if: success()
        run: |
          echo "## Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** Successful" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Services:**" >> $GITHUB_STEP_SUMMARY
          echo "- User Service: http://localhost:${{ env.STAGING_USER_PORT }}" >> $GITHUB_STEP_SUMMARY
          echo "- Product Service: http://localhost:${{ env.STAGING_PRODUCT_PORT }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test Coverage:**" >> $GITHUB_STEP_SUMMARY
          echo "- Unit/Integration Tests: 83 tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- Functional Tests: Executed in staging" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          docker-compose -f docker-compose.staging.yml down -v
