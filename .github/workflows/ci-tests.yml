name: Final-Project CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  PYTHON_VERSION: '3.10'
  STAGING_USER_PORT: 4001
  STAGING_PRODUCT_PORT: 4002
  STAGING_USER_MYSQL_PORT: 4308
  STAGING_PRODUCT_MYSQL_PORT: 4309
  STAGING_MYSQL_PORT: 3306
  STAGING_USER_MYSQL_DB: 'user_staging'
  STAGING_PRODUCT_MYSQL_DB: 'product_staging'
  STAGING_USER_MYSQL_USER: 'staging_user'
  STAGING_PRODUCT_MYSQL_USER: 'staging_product_user'
  STAGING_DOCKER_NETWORK: staging_network

jobs:
  
  test-all-services:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
        mysql_version: ['8.0']

    services:
      mysql-user:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
      mysql-product:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3307:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Creating test environment file
        run: |
          cat > .env.test << EOF
          SECRET_KEY=test_fallback_secret_key_123
          USER_MYSQL_HOST=localhost
          USER_MYSQL_USER=test_user
          USER_MYSQL_PASSWORD=test_password_123
          USER_MYSQL_DB=auth_test
          USER_MYSQL_PORT=3306
          PRODUCT_MYSQL_HOST=localhost
          PRODUCT_MYSQL_USER=product_test_user
          PRODUCT_MYSQL_PASSWORD=test_password_123
          PRODUCT_MYSQL_DB=products_test
          PRODUCT_MYSQL_PORT=3307
          USER_SERVICE_URL=http://localhost:3001
          PRODUCT_SERVICE_URL=http://localhost:3002
          FLASK_ENV=test
          TESTING=True
          EOF

      - name: Install MySQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y mysql-client
      
      - name: wait for MySQL to be ready
        run: |
          until mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done

          until mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done

      
      - name: Initialize service database
        run: |
          mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 < user-service/init_test.sql
          mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 < product-service/product_init_test.sql

      - name: Install dependencies
        run: |
          cd user-service && pip install -r requirements.txt
          cd ../product-service && pip install -r requirements.txt 

      - name: Start user-service
        working-directory: ./user-service
        run: |
          echo "Starting user-service"
          python3 app.py &
          FLASK_PID_USER=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo $FLASK_PID_USER > user_service.pid 
          echo "User-service PID: $FLASK_PID_USER"
          sleep 30

      - name: Start product-service
        working-directory: ./product-service
        run: |
          echo "Starting product-service"
          python3 product_app.py &
          FLASK_PID_PRODUCT=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo FLASK_PID_PRODUCT > product-service.pid
          echo "Flask PID product-service: $FLASK_PID_PRODUCT"
          sleep 30
      
      -  name: Verification if both services are running
         run: |
          curl -f http://localhost:3001/health && echo "User Service: OK"
          curl -f http://localhost:3002/health && echo "Product Service: OK"

      - name: Run test-user-service
        working-directory: ./user-service/tests
        run: |
          python3 -m pytest test_user_service.py -v -s
      
      - name: Run test-product-service
        working-directory: ./product-service/products_tests
        run: |
          python3 -m pytest test_product_service.py -v -s
      
      - name: Stop Flask services  
        if: always()
        run: |
          echo "Stopping Flask services..."
          pkill -f "python3 app.py" || true
          pkill -f "python3 product_app.py" || true
          echo "Flask services stopped"

      - name: Upload tests evidence
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tests evidence-${{ github.run_id }}
          path: |
            user-service/tests/evidence/
            product-service/products_tests/products_evidence/
          retention-days: 7
  
  build-staging-images:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    needs: test-all-services
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/test/staging-full-pipeline')

    outputs:
      user-image-tag: ${{ steps.tag.outputs.user-tag }}
      product-image-tag: ${{ steps.tag.outputs.product-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate docker image tags
        id: tag
        run: |
          DATE_TAG=$(date +'%Y%m%d')
          SHORT_SHA=${GITHUB_SHA::8}

          USER_TAG="user-service:staging-${DATE_TAG}-${SHORT_SHA}"
          PRODUCT_TAG="product-service:staging-${DATE_TAG}-${SHORT_SHA}"

          echo "user-tag=${USER_TAG}" >> $GITHUB_OUTPUT
          echo "product-tag=${PRODUCT_TAG}" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build user-service for staging
        run: |
          cd user-service
          docker build \
            -t ${{ steps.tag.outputs.user-tag }} \
            --build-arg ENVIRONMENT=staging \
            --build-arg PORT=${{env.STAGING_USER_PORT}} \
            --label "version=staging" \
            --label "commit=${GITHUB_SHA}" \
            --label "branch=${GITHUB_REF_NAME}" \
            --label "build-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .
      
      - name: Build product-service for staging
        run: |
          cd product-service
          docker build \
            -t ${{ steps.tag.outputs.product-tag }} \
            --build-arg ENVIRONMENT=staging \
            --build-arg PORT=${{env.STAGING_PRODUCT_PORT}} \
            --label "version=staging" \
            --label "commit=${GITHUB_SHA}" \
            --label "branch=${GITHUB_REF_NAME}" \
            --label "build-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .
      
      - name: Save docker images as artifacts
        run: |
          docker save ${{ steps.tag.outputs.user-tag }} -o user_service_staging.tar
          docker save ${{ steps.tag.outputs.product-tag }} -o product_service_staging.tar
      
      - name: Upload docker images
        uses: actions/upload-artifact@v4
        with:
          name: staging-images-${{ github.run_id }}
          path: |
            user_service_staging.tar
            product_service_staging.tar
          retention-days: 3
  
  deploy-staging:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    needs: build-staging-images
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/test/staging-full-pipeline')

    environment:
      name: staging
      url: http://localhost:${{ env.STAGING_USER_PORT }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download docker images
        uses: actions/download-artifact@v4
        with:
          name: staging-images-${{ github.run_id }}
      
      - name: Load docker images
        run: |
          docker load -i user_service_staging.tar
          docker load -i product_service_staging.tar
      
      - name: Create docker network for staging
        run: |
          docker network create ${{ env.STAGING_DOCKER_NETWORK }} || echo "Network already exists"
      
      - name: Cleanup previous staging containers
        run: |
          docker stop user-service-staging mysql-user-staging product-service-staging mysql-product-staging 2>/dev/null || true
          docker rm user-service-staging mysql-user-staging product-service-staging mysql-product-staging 2>/dev/null || true
      
      - name: Deploy MySQL for staging
        env:
          STAGING_DB_ROOT_PASSWORD: ${{ secrets.STAGING_DB_ROOT_PASSWORD }} #Github Secrets transformed into shell environment variables security method to not expose the value 
          STAGING_USER_DB_PASSWORD: ${{ secrets.STAGING_USER_DB_PASSWORD }}
          STAGING_PRODUCT_DB_PASSWORD: ${{ secrets.STAGING_PRODUCT_DB_PASSWORD }}
        run: |
          docker run -d \
            --name mysql-user-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -e MYSQL_ROOT_PASSWORD=$STAGING_DB_ROOT_PASSWORD \
            -e MYSQL_DATABASE=${{ env.STAGING_USER_DB }}  \
            -e MYSQL_USER=${{ env.STAGING_USER_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_USER_DB_PASSWORD \
            -p ${{ env.STAGING_USER_MYSQL_PORT }}:${{ env.STAGING_MYSQL_PORT }} \
            --health-cmd="mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD" \
            --health-interval=10s \
            mysql:8.0

          docker run -d \
            --name mysql-product-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -e MYSQL_ROOT_PASSWORD=${STAGING_DB_ROOT_PASSWORD} \
            -e MYSQL_DATABASE=${{ env.STAGING_PRODUCT_DB }}  \
            -e MYSQL_USER=${{ env.STAGING_PRODUCT_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_PRODUCT_DB_PASSWORD \
            -p ${{ env.STAGING_PRODUCT_MYSQL_PORT }}:${{ env.STAGING_MYSQL_PORT }} \
            --health-cmd="mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD" \
            --health-interval=10s \
            mysql:8.0
            
          echo "Waiting for MySQL containers to be healthy"
          for i in {1..30}; do
            if docker exec mysql-user-staging mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD 2>/dev/null && \
              docker exec mysql-product-staging mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD 2>/dev/null; then
              echo "MySQL containers are healthy"
              break
            fi
            echo "MySQL containers not healthy yet, retrying"
            sleep 10
          done
            
      
      - name: Initialize staging databases
        env:
          STAGING_DB_ROOT_PASSWORD: ${{ secrets.STAGING_DB_ROOT_PASSWORD }}
        run: |
          mysql -h 127.0.0.1 -P ${{ env.STAGING_USER_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD < scripts/structure/init-staging.sql
          mysql -h 127.0.0.1 -P ${{ env.STAGING_PRODUCT_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD < scripts/structure/product-staging_init.sql
          
          if [ -f "scripts/staging/user-service-staging-mockdata.sql" ]; then
            mysql -h 127.0.0.1 -P ${{ env.STAGING_USER_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD < scripts/staging/user-service-staging-mockdata.sql
          fi
    
          if [ -f "scripts/staging/product-service-staging-mockdata.sql" ]; then
            mysql -h 127.0.0.1 -P ${{ env.STAGING_PRODUCT_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD < scripts/staging/product-service-staging-mockdata.sql
          fi
          
      - name: Deploy User Service to staging
        env:
          STAGING_JWT_SECRET: ${{ secrets.STAGING_JWT_SECRET }}
          STAGING_USER_DB_PASSWORD: ${{ secrets.STAGING_USER_DB_PASSWORD }}
        run: |
          docker run -d \
            --name user-service-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -p ${{ env.STAGING_USER_PORT }}:${{ env.STAGING_USER_PORT }} \
            -e USER_MYSQL_HOST=mysql-user-staging \
            -e USER_MYSQL_USER=${{ env.STAGING_USER_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_USER_DB_PASSWORD \
            -e MYSQL_DB=${{ env.STAGING_USER_MYSQL_DB }} \
            -e USER_MYSQL_PORT=${{ env.STAGING_MYSQL_PORT }}\
            -e SECRET_KEY=$STAGING_JWT_SECRET \
            -e FLASK_ENV=staging \
            ${{ needs.build-staging-images.outputs.user-image-tag }}
            
      - name: Deploy Product Service to staging
        env:
          STAGING_JWT_SECRET: ${{ secrets.STAGING_JWT_SECRET }}
          STAGING_PRODUCT_DB_PASSWORD: ${{ secrets.STAGING_PRODUCT_DB_PASSWORD }}
        run: |
          docker run -d \
            --name product-service-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -p ${{ env.STAGING_PRODUCT_PORT }}:${{ env.STAGING_PRODUCT_PORT }} \
            -e PRODUCT_MYSQL_HOST=mysql-product-staging \
            -e PRODUCT_MYSQL_USER=${{ env.STAGING_PRODUCT_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_PRODUCT_DB_PASSWORD \
            -e MYSQL_DB=${{ env.STAGING_PRODUCT_DB }}\
            -e PRODUCT_MYSQL_PORT=${{ env.STAGING_MYSQL_PORT }} \
            -e SECRET_KEY=$STAGING_JWT_SECRET \
            -e FLASK_ENV=staging \
            ${{ needs.build-staging-images.outputs.product-image-tag }}
            
      - name: Wait for services to start
        run: |
          echo "Waiting for services to be ready"
          sleep 25
          
      - name: Verify staging deployment
        run: |
          echo "Testing services"
          for i in {1..10}; do
            if curl -f http://localhost:${{ env.STAGING_USER_PORT }}/health && \
               curl -f http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health; then
               echo "Both services are up"
               break
            fi
              echo "Services not up yet, retrying"
              sleep 10
            done
          
      - name: Run basic integration tests on staging
        run: |
          echo "Running basic integration tests on staging"
          
          echo "Testing user creation"
          curl -X POST http://localhost:${{ env.STAGING_USER_PORT }}/register \
            -H "Content-Type: application/json" \
            -d '{"email":"test@staging.com","password":"staging_test123"}' \
            && echo "User creation test passed" || echo " User creation test warning"
            
          echo "Testing product listing"
          curl -f http://localhost:${{ env.STAGING_PRODUCT_PORT }}/products \
            && echo "Product listing test passed"
      
      - name: Record deployment
        if: success()
        run: |
          echo "STAGING DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "Timestamp: $(date)"
          echo "Commit: ${{ github.sha }}"
          echo "User Service: http://localhost:${{ env.STAGING_USER_PORT }}"
          echo "Product Service: http://localhost:${{ env.STAGING_PRODUCT_PORT }}"
