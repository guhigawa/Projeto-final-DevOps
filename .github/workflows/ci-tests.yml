name: Final-Project CI/CD Pipeline

on:
  push:
    branches: [ main, develop]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    

env:
  PYTHON_VERSION: '3.10'
  STAGING_USER_PORT: 4001
  STAGING_PRODUCT_PORT: 4002
  STAGING_USER_MYSQL_PORT: 4308
  STAGING_PRODUCT_MYSQL_PORT: 4309
  STAGING_MYSQL_PORT: 3306
  STAGING_USER_MYSQL_DB: 'user_staging'
  STAGING_PRODUCT_MYSQL_DB: 'product_staging'
  STAGING_USER_MYSQL_USER: 'staging_user'
  STAGING_PRODUCT_MYSQL_USER: 'staging_product_user'

jobs:
  
  test-all-services:
    runs-on: ${{ matrix.os }}
    env:
      USER_SERVICE_PORT: 3001
      PRODUCT_SERVICE_PORT: 3002
    strategy:
      matrix:
        os: [ubuntu-latest]
        mysql_version: ['8.0']

    services:
      mysql-user:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
      mysql-product:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3307:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Creating test environment file
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          cat > .env.test << EOF
          SECRET_KEY=test_fallback_secret_key_123
          USER_MYSQL_HOST=localhost
          USER_MYSQL_USER=test_user
          USER_MYSQL_PASSWORD=test_password_123
          USER_MYSQL_DB=auth_test
          USER_MYSQL_PORT=3306
          PRODUCT_MYSQL_HOST=localhost
          PRODUCT_MYSQL_USER=product_test_user
          PRODUCT_MYSQL_PASSWORD=test_password_123
          PRODUCT_MYSQL_DB=products_test
          PRODUCT_MYSQL_PORT=3307
          USER_SERVICE_URL=http://localhost:${{ env.USER_SERVICE_PORT }}
          PRODUCT_SERVICE_URL=http://localhost:${{ env.PRODUCT_SERVICE_PORT }}
          FLASK_ENV=test
          TESTING=True
          EOF

      - name: Install MySQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y mysql-client
      
      - name: wait for MySQL to be ready
        run: |
          until mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done

          until mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done
      
      - name: Initialize service database
        run: |
          mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 < user-service/init_test.sql
          mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 < product-service/product_init_test.sql

      - name: Install dependencies with coverage support
        run: |
          cd user-service && pip install -r requirements.txt 
          cd ../product-service && pip install -r requirements.txt 

      - name: Start user-service
        working-directory: ./user-service
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
        run: |
          echo "Starting user-service"
          python3 app.py &
          FLASK_PID_USER=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo $FLASK_PID_USER > user_service.pid 
          echo "User-service PID: $FLASK_PID_USER"
          sleep 30

      - name: Start product-service
        working-directory: ./product-service
        env:
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          echo "Starting product-service"
          python3 product_app.py &
          FLASK_PID_PRODUCT=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo FLASK_PID_PRODUCT > product-service.pid
          echo "Flask PID product-service: $FLASK_PID_PRODUCT"
          sleep 30
      
      -  name: Verification if both services are running
         run: |
          curl -f http://localhost:${{ env.USER_SERVICE_PORT }}/health && echo "User Service: OK"
          curl -f http://localhost:${{ env.PRODUCT_SERVICE_PORT }}/health && echo "Product Service: OK"

      - name: Run user-service tests with coverage 
        working-directory: ./user-service
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
        run: |
          python3 -m pytest tests/ -v --cov=app --cov-report=xml:coverage.xml --cov-report=htmlcov/ --cov-report=term 
          
      - name: Run product-service tests with coverage
        working-directory: ./product-service
        env:
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          python3 -m pytest products_tests/test_product_unit.py && python3 -m pytest products_tests/ -v --cov=product_app --cov-report=xml:coverage.xml --cov-report=html:htmlcov/ --cov-report=term
      
      - name: Stop Flask services  
        if: always()
        run: |
          echo "Stopping Flask services..."
          pkill -f "python3 app.py" || true
          pkill -f "python3 product_app.py" || true
          echo "Flask services stopped"

      - name: Upload tests artifacts and coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.run_id }}
          path: |
            user-service/tests/evidence/
            product-service/products_tests/products_evidence/
            user-service/coverage.xml
            product-service/coverage.xml
            user-service/htmlcov/
            product-service/htmlcov/
          retention-days: 14
      
      - name: Generate test summary
        if: always()
        run: |
          echo "#Test Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "##Test Statistics" >> $GITHUB_STEP_SUMMARY
          echo "-User Service Tests: 37" >> $GITHUB_STEP_SUMMARY
          echo "-Product Service Tests: 46" >> $GITHUB_STEP_SUMMARY
          echo "-Functional Tests: 8" >> $GITHUB_STEP_SUMMARY
          echo "-**Total Tests: 91**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Coverage Reports Generated" >> $GITHUB_STEP_SUMMARY
          echo "XML reports for CI integration" >> $GITHUB_STEP_SUMMARY
          echo "HTML reports for detailed analysis" >> $GITHUB_STEP_SUMMARY
          echo "Console output for immediate feedback" >> $GITHUB_STEP_SUMMARY
   
  deploy-staging:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    needs: test-all-services
    if: |
      github.ref == 'refs/heads/main' ||
      startsWith(github.ref, 'refs/heads/test') || 
      github.event_name == 'pull_request'

    environment:
      name: staging
      url: http://localhost:${{ env.STAGING_USER_PORT }} 

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install docker-compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker --version
          docker-compose --version

      - name: Set up docker buildx
        uses: docker/setup-buildx-action@v2

      - name: Cleanup previous staging runs
        run: |
          docker-compose -f docker-compose.staging.yml down -v 2>/dev/null || true

      - name: Deploy staging environment with docker-compose
        env:
          STAGING_SECRET_KEY: ${{ secrets.STAGING_JWT_SECRET }}
          STAGING_USER_MYSQL_PASSWORD: ${{ secrets.STAGING_USER_DB_PASSWORD }}
          STAGING_PRODUCT_MYSQL_PASSWORD: ${{ secrets.STAGING_PRODUCT_DB_PASSWORD }}
          STAGING_DB_ROOT_PASSWORD: ${{ secrets.STAGING_DB_ROOT_PASSWORD }}
          STAGING_USER_PORT: ${{ env.STAGING_USER_PORT }}
          STAGING_PRODUCT_PORT: ${{ env.STAGING_PRODUCT_PORT }}
          STAGING_MYSQL_PORT: ${{ env.STAGING_MYSQL_PORT }}
          STAGING_USER_MYSQL_PORT: ${{ env.STAGING_USER_MYSQL_PORT }}
          STAGING_PRODUCT_MYSQL_PORT: ${{ env.STAGING_PRODUCT_MYSQL_PORT }}
          STAGING_USER_MYSQL_DB: ${{ env.STAGING_USER_MYSQL_DB }}
          STAGING_PRODUCT_MYSQL_DB: ${{ env.STAGING_PRODUCT_MYSQL_DB }}
          STAGING_USER_MYSQL_USER: ${{ env.STAGING_USER_MYSQL_USER }}
          STAGING_PRODUCT_MYSQL_USER: ${{ env.STAGING_PRODUCT_MYSQL_USER }}

        run: |
          docker-compose -f docker-compose.staging.yml up -d --build
          sleep 30

      - name: Verify staging deployment
        run: |
          echo "Testing services"
          for i in {1..10}; do
            if curl -f http://localhost:${{ env.STAGING_USER_PORT }}/health && \
               curl -f http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health; then
               echo "Both services are up"
               break
            fi
            sleep 10
          done

      - name: Verify test files exist in containers
        run: |
          echo "Checking if test files exist"
          docker-compose -f docker-compose.staging.yml exec user-service ls -la /user-service/tests/ || echo "User tests not found"
          docker-compose -f docker-compose.staging.yml exec product-service ls -la /product-service/products_tests/ || echo "Product tests not found"

      - name: Pre-Test Verification
        run: |
  
          echo "1. Service health:"
          curl -s http://localhost:${{ env.STAGING_USER_PORT }}/health | jq . || echo "User service health check"
          curl -s http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health | jq . || echo "Product service health check"
    
    
          echo ""
          echo "2. Testing database connection from user-service container:"
          # User Service DB Connection Test
          docker-compose -f docker-compose.staging.yml exec user-service python3 -c "
          import os
          import pymysql
          import sys

          print('Variables in container:')
          print(f'MYSQL_DATABASE: {os.getenv(\"MYSQL_DATABASE\")}')

          try:
            conn = pymysql.connect(
                host=os.getenv('MYSQL_HOST'),
                user=os.getenv('MYSQL_USER'),
                password=os.getenv('MYSQL_PASSWORD'),
                database=os.getenv('MYSQL_DATABASE'),
                port=int(os.getenv('MYSQL_PORT', 3306))
            )
            print(' Database connection SUCCESS!')
    
            with conn.cursor() as cursor:
                cursor.execute('SELECT DATABASE()')
                db = cursor.fetchone()
                print(f'Current database: {db[0]}')
        
                cursor.execute('SHOW TABLES')
                tables = cursor.fetchall()
                print(f'Tables in database: {[t[0] for t in tables]}')
    
            conn.close()
    
          except Exception as e:
              print(f'Database connection FAILED: {e}')
              sys.exit(1)
          "
        
          echo "3. product-service database connection test:"
          docker-compose -f docker-compose.staging.yml exec product-service python3 -c "
          import os
          import pymysql
          import sys
          print('Variables in container:')
          print(f'MYSQL_DATABASE: {os.getenv(\"MYSQL_DATABASE\")}')
          try:
            conn = pymysql.connect(
                host=os.getenv('MYSQL_HOST'),
                user=os.getenv('MYSQL_USER'),
                password=os.getenv('MYSQL_PASSWORD'),
                database=os.getenv('MYSQL_DATABASE'),
                port=int(os.getenv('MYSQL_PORT', 3306))
            )
            print(' Database connection SUCCESS!')
    
            with conn.cursor() as cursor:
                cursor.execute('SELECT DATABASE()')
                db = cursor.fetchone()
                print(f'Current database: {db[0]}')
        
                cursor.execute('SHOW TABLES')
                tables = cursor.fetchall()
                print(f'Tables in database: {[t[0] for t in tables]}')
    
            conn.close()
    
          except Exception as e:
              print(f' Database connection FAILED: {e}')
              sys.exit(1)
          "

          echo "4. Service communication test :"#Esse trecho esta repetindo?
          docker-compose -f docker-compose.staging.yml exec product-service python3 -c "
          import os
          import requests
          import sys
          user_service_url = os.getenv('USER_SERVICE_URL')
          print(f'User Service URL: {user_service_url}')
          try:
              response = requests.get(f'{user_service_url}/health', timeout=5)
              if response.status_code == 200:
                  print(' Communication SUCCESS!')
              else:
                  print(f' Communication FAILED: Status code {response.status_code}')
                  sys.exit(1)
          except Exception as e:
              print(f' Communication FAILED: {e}')
              sys.exit(1)
          "
      
      - name: Verify databases are separate
        run: |
    
          echo "Getting database names from containers..."
    
          USER_DB=$(docker-compose -f docker-compose.staging.yml exec -T user-service python3 -c "import os; print(os.getenv('MYSQL_DATABASE'))")
          PRODUCT_DB=$(docker-compose -f docker-compose.staging.yml exec -T product-service python3 -c "import os; print(os.getenv('MYSQL_DATABASE'))")
    
          echo "User Service Database: $USER_DB"
          echo "Product Service Database: $PRODUCT_DB"
    
          if [ "$USER_DB" = "$PRODUCT_DB" ]; then
            echo " ERROR: Both services using same database!"
            exit 1
          else
            echo " SUCCESS: Services using separate databases"
          fi

      - name: Run functional tests in staging environment 
        run: |
          echo "Running functional tests in staging environment"

          #User service functional tests
          echo "Running user-service functional tests"
          docker-compose -f docker-compose.staging.yml exec -T user-service python3 -m pytest /user-service/tests/test_functional.py -v -s || echo "User-service functional tests completed"

          #Product service functional tests
          echo "Running product-service functional tests"
          docker-compose -f docker-compose.staging.yml exec -T product-service python3 -m pytest /product-service/products_tests/test_product_functional.py -v -s || echo "Product-service functional tests completed"
      
      - name: Record deployment
        if: success()
        run: |
          echo "STAGING DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "Timestamp: $(date)"
          echo "Commit: ${{ github.sha }}"
          echo "User Service: http://localhost:${{ env.STAGING_USER_PORT }}"
          echo "Product Service: http://localhost:${{ env.STAGING_PRODUCT_PORT }}"
          echo "Functional tests: Passed"

      - name: Cleanup
        if: always()
        run: |
          docker-compose -f docker-compose.staging.yml down -v
