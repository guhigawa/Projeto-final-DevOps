name: Final-Project CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  PYTHON_VERSION: '3.10'
  STAGING_USER_PORT: 4001
  STAGING_PRODUCT_PORT: 4002
  STAGING_USER_MYSQL_PORT: 4308
  STAGING_PRODUCT_MYSQL_PORT: 4309
  STAGING_MYSQL_PORT: 3306
  STAGING_USER_MYSQL_DB: 'user_staging'
  STAGING_PRODUCT_MYSQL_DB: 'product_staging'
  STAGING_USER_MYSQL_USER: 'staging_user'
  STAGING_PRODUCT_MYSQL_USER: 'staging_product_user'
  STAGING_DOCKER_NETWORK: staging_network

jobs:
  
  test-all-services:
    runs-on: ${{ matrix.os }}
    env:
      USER_SERVICE_PORT: 3001
      PRODUCT_SERVICE_PORT: 3002
    strategy:
      matrix:
        os: [ubuntu-latest]
        mysql_version: ['8.0']

    services:
      mysql-user:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
      mysql-product:
        image: mysql:${{ matrix.mysql_version }}
        env:
          MYSQL_ROOT_PASSWORD: test_root_password_123
        ports:
          - 3307:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -ptest_root_password_123"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Debug branch Info
        run: |
          echo "GITHUB_REF: $GITHUB_REF"
          echo "GITHUB_REF_NAME: $GITHUB_REF_NAME"
          echo "github.ref no contexto: ${{ github.ref }}"

      - name: Debug Environment Info
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          echo "User Service Port: $USER_SERVICE_PORT"
          echo "PRODUCT_SERVICE_PORT: $PRODUCT_SERVICE_PORT"
          echo "Testing will use: http://localhost:$USER_SERVICE_PORT"
          echo "Testing will use: http://localhost:$PRODUCT_SERVICE_PORT"
      
      - name: Creating test environment file
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          cat > .env.test << EOF
          SECRET_KEY=test_fallback_secret_key_123
          USER_MYSQL_HOST=localhost
          USER_MYSQL_USER=test_user
          USER_MYSQL_PASSWORD=test_password_123
          USER_MYSQL_DB=auth_test
          USER_MYSQL_PORT=3306
          PRODUCT_MYSQL_HOST=localhost
          PRODUCT_MYSQL_USER=product_test_user
          PRODUCT_MYSQL_PASSWORD=test_password_123
          PRODUCT_MYSQL_DB=products_test
          PRODUCT_MYSQL_PORT=3307
          USER_SERVICE_URL=http://localhost:${{ env.USER_SERVICE_PORT }}
          PRODUCT_SERVICE_URL=http://localhost:${{ env.PRODUCT_SERVICE_PORT }}
          FLASK_ENV=test
          TESTING=True
          EOF

      - name: Install MySQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y mysql-client
      
      - name: wait for MySQL to be ready
        run: |
          until mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done

          until mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 -e  "SELECT 1"; do echo "waiting for MySQL"
            sleep 2
          done

      
      - name: Initialize service database
        run: |
          mysql -h 127.0.0.1 -P 3306 -u root -ptest_root_password_123 < user-service/init_test.sql
          mysql -h 127.0.0.1 -P 3307 -u root -ptest_root_password_123 < product-service/product_init_test.sql

      - name: Install dependencies
        run: |
          cd user-service && pip install -r requirements.txt
          cd ../product-service && pip install -r requirements.txt 

      - name: Start user-service
        working-directory: ./user-service
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
        run: |
          echo "Starting user-service"
          python3 app.py &
          FLASK_PID_USER=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo $FLASK_PID_USER > user_service.pid 
          echo "User-service PID: $FLASK_PID_USER"
          sleep 30

      - name: Start product-service
        working-directory: ./product-service
        env:
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          echo "Starting product-service"
          python3 product_app.py &
          FLASK_PID_PRODUCT=$! #cli command to store the last executed command in the background into the variable FLASK_PID
          echo FLASK_PID_PRODUCT > product-service.pid
          echo "Flask PID product-service: $FLASK_PID_PRODUCT"
          sleep 30
      
      -  name: Verification if both services are running
         run: |
          curl -f http://localhost:${{ env.USER_SERVICE_PORT }}/health && echo "User Service: OK"
          curl -f http://localhost:${{ env.PRODUCT_SERVICE_PORT }}/health && echo "Product Service: OK"

      - name: Run test-user-service
        working-directory: ./user-service/tests
        env:
          USER_SERVICE_PORT: ${{ env.USER_SERVICE_PORT }}
        run: |
          python3 -m pytest test_user_service.py -v -s
      
      - name: Run test-product-service
        working-directory: ./product-service/products_tests
        env:
          PRODUCT_SERVICE_PORT: ${{ env.PRODUCT_SERVICE_PORT }}
        run: |
          python3 -m pytest test_product_service.py -v -s
      
      - name: Stop Flask services  
        if: always()
        run: |
          echo "Stopping Flask services..."
          pkill -f "python3 app.py" || true
          pkill -f "python3 product_app.py" || true
          echo "Flask services stopped"

      - name: Upload tests evidence
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tests evidence-${{ github.run_id }}
          path: |
            user-service/tests/evidence/
            product-service/products_tests/products_evidence/
          retention-days: 7
  
  build-staging-images:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    needs: test-all-services
    if: |
      github.ref == 'refs/heads/main' || 
      startsWith(github.ref, 'refs/heads/test') ||
      github.event_name == 'pull_request'

    outputs:
      user-image-tag: ${{ steps.tag.outputs.user-tag }}
      product-image-tag: ${{ steps.tag.outputs.product-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate docker image tags
        id: tag
        run: |
          DATE_TAG=$(date +'%Y%m%d')
          SHORT_SHA=${GITHUB_SHA::8}

          USER_TAG="user-service:staging-${DATE_TAG}-${SHORT_SHA}"
          PRODUCT_TAG="product-service:staging-${DATE_TAG}-${SHORT_SHA}"

          echo "user-tag=${USER_TAG}" >> $GITHUB_OUTPUT
          echo "product-tag=${PRODUCT_TAG}" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build user-service for staging
        run: |
          cd user-service
          docker build \
            -t ${{ steps.tag.outputs.user-tag }} \
            --build-arg ENVIRONMENT=staging \
            --build-arg PORT=${{env.STAGING_USER_PORT}} \
            --label "version=staging" \
            --label "commit=${GITHUB_SHA}" \
            --label "branch=${GITHUB_REF_NAME}" \
            --label "build-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .
      
      - name: Build product-service for staging
        run: |
          cd product-service
          docker build \
            -t ${{ steps.tag.outputs.product-tag }} \
            --build-arg ENVIRONMENT=staging \
            --build-arg PORT=${{env.STAGING_PRODUCT_PORT}} \
            --label "version=staging" \
            --label "commit=${GITHUB_SHA}" \
            --label "branch=${GITHUB_REF_NAME}" \
            --label "build-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .
      
      - name: Save docker images as artifacts
        run: |
          docker save ${{ steps.tag.outputs.user-tag }} -o user_service_staging.tar
          docker save ${{ steps.tag.outputs.product-tag }} -o product_service_staging.tar
      
      - name: Upload docker images
        uses: actions/upload-artifact@v4
        with:
          name: staging-images-${{ github.run_id }}
          path: |
            user_service_staging.tar
            product_service_staging.tar
          retention-days: 3
  
  deploy-staging:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
    needs: build-staging-images
    if: |
      github.ref == 'refs/heads/main' || 
      startsWith(github.ref, 'refs/heads/test') ||
      github.event_name == 'pull_request'

    environment:
      name: staging
      url: http://localhost:${{ env.STAGING_USER_PORT }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download docker images
        uses: actions/download-artifact@v4
        with:
          name: staging-images-${{ github.run_id }}
      
      - name: Load docker images
        run: |
          docker load -i user_service_staging.tar
          docker load -i product_service_staging.tar
      
      - name: Create docker network for staging
        run: |
          docker network create ${{ env.STAGING_DOCKER_NETWORK }} || echo "Network already exists"
      
      - name: Cleanup previous staging containers
        run: |
          docker stop user-service-staging mysql-user-staging product-service-staging mysql-product-staging 2>/dev/null || true
          docker rm user-service-staging mysql-user-staging product-service-staging mysql-product-staging 2>/dev/null || true
      
      - name: Deploy MySQL for staging
        env:
          STAGING_DB_ROOT_PASSWORD: ${{ secrets.STAGING_DB_ROOT_PASSWORD }} #Github Secrets transformed into shell environment variables security method to not expose the value 
          STAGING_USER_DB_PASSWORD: ${{ secrets.STAGING_USER_DB_PASSWORD }}
          STAGING_PRODUCT_DB_PASSWORD: ${{ secrets.STAGING_PRODUCT_DB_PASSWORD }}
        run: |
          docker run -d \
            --name mysql-user-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -e MYSQL_ROOT_PASSWORD=$STAGING_DB_ROOT_PASSWORD \
            -e MYSQL_DATABASE=${{ env.STAGING_USER_MYSQL_DB }}  \
            -e MYSQL_USER=${{ env.STAGING_USER_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_USER_DB_PASSWORD \
            -p ${{ env.STAGING_USER_MYSQL_PORT }}:${{ env.STAGING_MYSQL_PORT }} \
            --health-cmd="mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD" \
            --health-interval=10s \
            mysql:8.0

          docker run -d \
            --name mysql-product-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -e MYSQL_ROOT_PASSWORD=${STAGING_DB_ROOT_PASSWORD} \
            -e MYSQL_DATABASE=${{ env.STAGING_PRODUCT_MYSQL_DB }}  \
            -e MYSQL_USER=${{ env.STAGING_PRODUCT_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_PRODUCT_DB_PASSWORD \
            -p ${{ env.STAGING_PRODUCT_MYSQL_PORT }}:${{ env.STAGING_MYSQL_PORT }} \
            --health-cmd="mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD" \
            --health-interval=10s \
            mysql:8.0
            
          echo "Waiting for MySQL containers to be healthy"
          for i in {1..30}; do
            if docker exec mysql-user-staging mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD 2>/dev/null && \
              docker exec mysql-product-staging mysqladmin ping -h localhost -u root -p$STAGING_DB_ROOT_PASSWORD 2>/dev/null; then
              echo "MySQL containers are healthy"
              break
            fi
            echo "MySQL containers not healthy yet, retrying"
            sleep 10
          done
            
      
      - name: Initialize staging databases
        env:
          STAGING_DB_ROOT_PASSWORD: ${{ secrets.STAGING_DB_ROOT_PASSWORD }}
        run: |
          echo "Database initialization"

          echo "Making sure databases exists"
          mysql -h 127.0.0.1 -P ${{ env.STAGING_USER_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD -e "CREATE DATABASE IF NOT EXISTS ${{ env.STAGING_USER_MYSQL_DB }};"
          mysql -h 127.0.0.1 -P ${{ env.STAGING_PRODUCT_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD -e "CREATE DATABASE IF NOT EXISTS ${{ env.STAGING_PRODUCT_MYSQL_DB }};" 

          echo "Granting permissions to user-service"
          mysql -h 127.0.0.1 -P ${{ env.STAGING_USER_MYSQL_PORT }}  -u root -p$STAGING_DB_ROOT_PASSWORD -e "GRANT ALL PRIVILEGES ON ${{ env.STAGING_USER_MYSQL_DB }}.* TO '${{ env.STAGING_USER_MYSQL_USER }}'@'%'; FLUSH PRIVILEGES;"
          mysql -h 127.0.0.1 -P ${{ env.STAGING_PRODUCT_MYSQL_PORT }}  -u root -p$STAGING_DB_ROOT_PASSWORD -e "GRANT ALL PRIVILEGES ON ${{ env.STAGING_PRODUCT_MYSQL_DB }}.* TO '${{ env.STAGING_PRODUCT_MYSQL_USER }}'@'%'; FLUSH PRIVILEGES;"

          echo "Executing scripts to create tables"
          mysql -h 127.0.0.1 -P ${{ env.STAGING_USER_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD ${{ env.STAGING_USER_MYSQL_DB }} < scripts/structure/init-staging.sql
          mysql -h 127.0.0.1 -P ${{ env.STAGING_PRODUCT_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD ${{ env.STAGING_PRODUCT_MYSQL_DB }} < scripts/structure/product-staging_init.sql
          
          echo "Executing scripts to start mockdata in tables created"
          if [ -f "scripts/staging/user-service-staging-mockdata.sql" ]; then
            mysql -h 127.0.0.1 -P ${{ env.STAGING_USER_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD ${{ env.STAGING_USER_MYSQL_DB }} < scripts/staging/user-service-staging-mockdata.sql || echo "Warning could not load mock data"
          else
            echo "No user mock data file found"
          fi
    
          if [ -f "scripts/staging/product-service-staging-mockdata.sql" ]; then
            mysql -h 127.0.0.1 -P ${{ env.STAGING_PRODUCT_MYSQL_PORT }} -u root -p$STAGING_DB_ROOT_PASSWORD ${{ env.STAGING_PRODUCT_MYSQL_DB }} < scripts/staging/product-service-staging-mockdata.sql || echo "Warning could not load mock data"
          else
            echo "No user mock data file found"
          fi

          echo "Database initialization complete"

      - name: Deploy User Service to staging
        env:
          STAGING_JWT_SECRET: ${{ secrets.STAGING_JWT_SECRET }}
          STAGING_USER_DB_PASSWORD: ${{ secrets.STAGING_USER_DB_PASSWORD }}
        run: |
          echo "Deploying user service"
          docker run -d \
            --name user-service-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -p ${{ env.STAGING_USER_PORT }}:${{ env.STAGING_USER_PORT }} \
            -e USER_MYSQL_HOST=mysql-user-staging \
            -e USER_MYSQL_USER=${{ env.STAGING_USER_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_USER_DB_PASSWORD \
            -e MYSQL_DATABASE=${{ env.STAGING_USER_MYSQL_DB }} \
            -e USER_MYSQL_PORT=${{ env.STAGING_MYSQL_PORT }}\
            -e SECRET_KEY=$STAGING_JWT_SECRET \
            -e FLASK_ENV=staging \
            -e FLASK_RUN_PORT=${{ env.STAGING_USER_PORT }} \
            ${{ needs.build-staging-images.outputs.user-image-tag }}      

      - name: Deploy Product Service to staging
        env:
          STAGING_JWT_SECRET: ${{ secrets.STAGING_JWT_SECRET }}
          STAGING_PRODUCT_DB_PASSWORD: ${{ secrets.STAGING_PRODUCT_DB_PASSWORD }}
        run: |
          echo "Deploying product service"
          docker run -d \
            --name product-service-staging \
            --network ${{ env.STAGING_DOCKER_NETWORK }} \
            -p ${{ env.STAGING_PRODUCT_PORT }}:${{ env.STAGING_PRODUCT_PORT }} \
            -e PRODUCT_MYSQL_HOST=mysql-product-staging \
            -e PRODUCT_MYSQL_USER=${{ env.STAGING_PRODUCT_MYSQL_USER }} \
            -e MYSQL_PASSWORD=$STAGING_PRODUCT_DB_PASSWORD \
            -e MYSQL_DATABASE=${{ env.STAGING_PRODUCT_MYSQL_DB }}\
            -e PRODUCT_MYSQL_PORT=${{ env.STAGING_MYSQL_PORT }} \
            -e SECRET_KEY=$STAGING_JWT_SECRET \
            -e FLASK_ENV=staging \
            -e FLASK_RUN_PORT=${{ env.STAGING_PRODUCT_PORT }} \
            ${{ needs.build-staging-images.outputs.product-image-tag }}
            
      - name: Wait for services to start
        run: |
          echo "Waiting for services to be ready"
          sleep 25
          
      - name: Verify staging deployment
        run: |
          echo "Testing services"
          for i in {1..10}; do
            if curl -f http://localhost:${{ env.STAGING_USER_PORT }}/health && \
               curl -f http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health; then
               echo "Both services are up"
               break
            fi
              echo "Services not up yet, retrying"
              sleep 10
            done
      
      - name:  Debug - Environment inside container
        run: |
          echo "=== DEBUG: Environment inside container ==="
          docker exec user-service-staging sh -c '
            echo "FLASK_RUN_PORT: $FLASK_RUN_PORT"
            echo "STAGING_USER_PORT: $STAGING_USER_PORT"
            echo "USER_SERVICE_PORT: $USER_SERVICE_PORT"
            echo "pwd: $(pwd)"
            echo "ls tests/:"
            ls -la /user-service/tests/ 2>/dev/null || echo "Not found"
          '
          echo "=== END DEBUG ==="

      - name: Verify test files exist in containers
        run: |
          echo "Checking if test files exist..."
          docker exec user-service-staging ls -la /user-service/tests/ || echo "User tests not found"
          docker exec product-service-staging ls -la /product-service/products_tests/ || echo "Product tests not found"

      - name: Pre-Test Verification
        run: |
          echo "=== PRE-TEST VERIFICATION ==="
    
  
          echo "1. Service health:"
          curl -s http://localhost:${{ env.STAGING_USER_PORT }}/health | jq . || echo "User service health check"
          curl -s http://localhost:${{ env.STAGING_PRODUCT_PORT }}/health | jq . || echo "Product service health check"
    
    
          echo ""
          echo "2. Testing database connection from user-service container:"
          docker exec user-service-staging python3 -c "
          import os
          import pymysql
          import sys

          print('Variables in container:')
          print(f'  MYSQL_DATABASE: {os.getenv(\"MYSQL_DATABASE\")}')
          print(f'  USER_MYSQL_DB: {os.getenv(\"USER_MYSQL_DB\")}')
          print(f'  MYSQL_DB: {os.getenv(\"MYSQL_DB\")}')

          try:
            conn = pymysql.connect(
                host=os.getenv('USER_MYSQL_HOST'),
                user=os.getenv('USER_MYSQL_USER'),
                password=os.getenv('MYSQL_PASSWORD'),
                database=os.getenv('MYSQL_DATABASE'),
                port=int(os.getenv('USER_MYSQL_PORT', 3306))
            )
            print(' Database connection SUCCESS!')
    
            with conn.cursor() as cursor:
                cursor.execute('SELECT DATABASE()')
                db = cursor.fetchone()
                print(f'  Current database: {db[0]}')
        
                cursor.execute('SHOW TABLES')
                tables = cursor.fetchall()
                print(f'  Tables in database: {[t[0] for t in tables]}')
    
            conn.close()
    
          except Exception as e:
              print(f' Database connection FAILED: {e}')
              sys.exit(1)
          "
    
            echo "=== END VERIFICATION ==="
      
      - name: Debug - Product Service Port Configuration
        run: |
          echo "=== DEBUG: Product Service Port ==="
    
          docker exec product-service-staging python3 -c "
          import os
          print('Environment variables in product-service container:')
          print(f'  FLASK_RUN_PORT: {os.getenv(\"FLASK_RUN_PORT\")}')
          print(f'  STAGING_PRODUCT_PORT: {os.getenv(\"STAGING_PRODUCT_PORT\")}')
          print(f'  PRODUCT_SERVICE_PORT: {os.getenv(\"PRODUCT_SERVICE_PORT\")}')
          print(f'  In Docker container: {os.path.exists(\"/.dockerenv\")}')

          def get_service_port():
              if os.path.exists('/.dockerenv'):
                  flask_port = os.getenv('FLASK_RUN_PORT')
                  if flask_port:
                      print(f'[Inside container] Using FLASK_RUN_PORT: {flask_port}')
                      return flask_port
    
              dev_port = os.getenv('PRODUCT_SERVICE_PORT')
              if dev_port:
                  print(f'[Outside container] Using PRODUCT_SERVICE_PORT: {dev_port}')
                  return dev_port
    
              staging_port = os.getenv('STAGING_PRODUCT_PORT')
              if staging_port:
                  print(f'[Staging] Using STAGING_PRODUCT_PORT: {staging_port}')
                  return staging_port
    
              print('[Default] Using port: 3002')
              return '3002'

          port = get_service_port()
          print(f'\\nResult: Will connect to http://localhost:{port}')
          print(f'Expected: Should be 4002 inside container')
          " 
    
              echo "=== END DEBUG ==="

      - name: Run test-user-service on staging container
        run: |
          echo "Runnig tests on staging user-service-staging container"
          docker exec user-service-staging python3 -m pytest /user-service/tests/test_user_service.py -v -s
      
      - name: Run test-product-service on staging container
        run: |
          echo "Runnig tests on staging product-service-staging container"
          docker exec product-service-staging python3 -m pytest /product-service/products_tests/test_product_service.py -v -s
          
      - name: Record deployment
        if: success()
        run: |
          echo "STAGING DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "Timestamp: $(date)"
          echo "Commit: ${{ github.sha }}"
          echo "User Service: http://localhost:${{ env.STAGING_USER_PORT }}"
          echo "Product Service: http://localhost:${{ env.STAGING_PRODUCT_PORT }}"
